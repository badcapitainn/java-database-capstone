# Smart Clinic Management System - Database Schema Design

This document outlines the database schema design for the Smart Clinic Management System, which uses a dual-database architecture:
- **MySQL** for structured, relational data (core operational data)
- **MongoDB** for flexible, document-based data (unstructured data, logs, notes)

## MySQL Database Design

MySQL stores the core operational data that requires strict validation, referential integrity, and transactional consistency. This includes patient records, doctor information, appointments, administrative data, and related structured entities.

### Table: patients

- **id**: INT, Primary Key, Auto Increment
  - Unique identifier for each patient record
  - Auto-generated by the database

- **name**: VARCHAR(100), Not Null
  - Patient's full name
  - Validation: Minimum 3 characters, maximum 100 characters

- **email**: VARCHAR(255), Not Null, Unique
  - Patient's email address for login and communication
  - Must be a valid email format (validated via application code)
  - Unique constraint ensures no duplicate accounts

- **password**: VARCHAR(255), Not Null
  - Hashed password for authentication (using bcrypt or similar)
  - Minimum 6 characters required
  - Never exposed in API responses

- **phone**: VARCHAR(10), Not Null
  - Patient's contact phone number
  - Validation: Exactly 10 digits (validated via regex pattern)

- **address**: VARCHAR(255), Not Null
  - Patient's residential address
  - Maximum 255 characters

- **created_at**: TIMESTAMP, Not Null, Default CURRENT_TIMESTAMP
  - Record creation timestamp for audit trail

- **updated_at**: TIMESTAMP, Not Null, Default CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
  - Last update timestamp for audit trail

**Relationships:**
- One-to-many with appointments (a patient can have many appointments)
- Cascade delete considerations: If a patient is deleted, should their appointments be deleted? (Recommendation: Soft delete or archive appointments for historical records)

---

### Table: doctors

- **id**: INT, Primary Key, Auto Increment
  - Unique identifier for each doctor record
  - Auto-generated by the database

- **name**: VARCHAR(100), Not Null
  - Doctor's full name
  - Validation: Minimum 3 characters, maximum 100 characters

- **specialty**: VARCHAR(50), Not Null
  - Medical specialty (e.g., "Cardiology", "Pediatrics", "Dermatology")
  - Validation: Minimum 3 characters, maximum 50 characters

- **email**: VARCHAR(255), Not Null, Unique
  - Doctor's email address for login and communication
  - Must be a valid email format (validated via application code)
  - Unique constraint ensures no duplicate accounts

- **password**: VARCHAR(255), Not Null
  - Hashed password for authentication (using bcrypt or similar)
  - Minimum 6 characters required
  - Never exposed in API responses

- **phone**: VARCHAR(10), Not Null
  - Doctor's contact phone number
  - Validation: Exactly 10 digits (validated via regex pattern)

- **consultation_fee**: DECIMAL(10, 2), Null
  - Fee charged per appointment consultation
  - Optional field for display to patients

- **experience_years**: INT, Null
  - Years of professional experience
  - Optional field for doctor profile

- **bio**: TEXT, Null
  - Doctor's biography or description
  - Optional field for detailed profile information

- **is_active**: BOOLEAN, Not Null, Default TRUE
  - Flag to indicate if doctor is currently active/available
  - Allows soft deletion without removing historical records

- **created_at**: TIMESTAMP, Not Null, Default CURRENT_TIMESTAMP
  - Record creation timestamp for audit trail

- **updated_at**: TIMESTAMP, Not Null, Default CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
  - Last update timestamp for audit trail

**Relationships:**
- One-to-many with appointments (a doctor can have many appointments)
- One-to-many with doctor_availability (if separate table is used)
- Cascade delete considerations: If a doctor is deleted, handle existing appointments appropriately (Recommendation: Soft delete to preserve appointment history)

---

### Table: appointments

- **id**: INT, Primary Key, Auto Increment
  - Unique identifier for each appointment record
  - Auto-generated by the database

- **doctor_id**: INT, Foreign Key → doctors(id), Not Null
  - References the doctor assigned to this appointment
  - Indexed for faster queries

- **patient_id**: INT, Foreign Key → patients(id), Not Null
  - References the patient who booked this appointment
  - Indexed for faster queries

- **appointment_time**: DATETIME, Not Null
  - Scheduled date and time for the appointment
  - Must be in the future when created
  - Indexed for faster date-range queries
  - Unique constraint on (doctor_id, appointment_time) to prevent double-booking

- **duration_minutes**: INT, Not Null, Default 60
  - Duration of the appointment in minutes
  - Default: 60 minutes (1 hour) as per requirements
  - Calculated end time: appointment_time + duration_minutes

- **status**: TINYINT, Not Null, Default 0
  - Appointment status enum:
    - 0 = Scheduled
    - 1 = Completed
    - 2 = Cancelled
    - 3 = No-show
  - Indexed for filtering by status

- **notes**: TEXT, Null
  - Optional notes provided by patient during booking
  - Can be updated by doctor before/during appointment

- **created_at**: TIMESTAMP, Not Null, Default CURRENT_TIMESTAMP
  - Record creation timestamp for audit trail

- **updated_at**: TIMESTAMP, Not Null, Default CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
  - Last update timestamp for audit trail

**Relationships:**
- Many-to-one with doctors
- Many-to-one with patients

**Constraints:**
- Unique constraint on (doctor_id, appointment_time) to prevent overlapping appointments for the same doctor
- Check constraint (if supported): appointment_time must be in the future
- Application-level validation: Ensure appointment_time doesn't conflict with doctor's unavailability periods

**Considerations:**
- Should a patient be allowed to have overlapping appointments? (Recommendation: Yes, for different doctors)
- Should appointment history be retained forever? (Recommendation: Yes, for medical records and audit purposes)
- Should cancelled appointments be deleted? (Recommendation: No, keep for historical tracking)

---

### Table: admin

- **id**: INT, Primary Key, Auto Increment
  - Unique identifier for each admin record
  - Auto-generated by the database

- **username**: VARCHAR(50), Not Null, Unique
  - Admin username for login authentication
  - Unique constraint ensures no duplicate usernames
  - Validation: Minimum 3 characters, maximum 50 characters

- **password**: VARCHAR(255), Not Null
  - Hashed password for authentication (using bcrypt or similar)
  - Minimum 6 characters required
  - Never exposed in API responses

- **email**: VARCHAR(255), Null, Unique
  - Admin email address for notifications and recovery
  - Optional but recommended for password reset functionality

- **role**: VARCHAR(20), Not Null, Default 'admin'
  - Admin role/permission level
  - Default: 'admin'
  - Future enhancement: Support multiple roles (super_admin, admin, support)

- **is_active**: BOOLEAN, Not Null, Default TRUE
  - Flag to indicate if admin account is active
  - Allows disabling accounts without deletion

- **created_at**: TIMESTAMP, Not Null, Default CURRENT_TIMESTAMP
  - Record creation timestamp for audit trail

- **updated_at**: TIMESTAMP, Not Null, Default CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
  - Last update timestamp for audit trail

**Relationships:**
- No direct foreign key relationships (admin manages other entities)

**Considerations:**
- Admin accounts should have the highest security standards
- Consider implementing login attempt tracking and account lockout mechanisms

---

### Table: doctor_availability (Optional but Recommended)

- **id**: INT, Primary Key, Auto Increment
  - Unique identifier for each availability record

- **doctor_id**: INT, Foreign Key → doctors(id), Not Null, ON DELETE CASCADE
  - References the doctor whose availability is being defined
  - Cascade delete: If doctor is deleted, remove availability records

- **day_of_week**: TINYINT, Not Null
  - Day of week (0 = Sunday, 1 = Monday, ..., 6 = Saturday)
  - For recurring weekly availability

- **start_time**: TIME, Not Null
  - Start time of availability slot (e.g., "09:00:00")

- **end_time**: TIME, Not Null
  - End time of availability slot (e.g., "17:00:00")
  - Must be after start_time

- **is_recurring**: BOOLEAN, Not Null, Default TRUE
  - Indicates if this is a recurring weekly schedule

- **specific_date**: DATE, Null
  - If not recurring, specific date for this availability
  - Used for one-time availability overrides

- **created_at**: TIMESTAMP, Not Null, Default CURRENT_TIMESTAMP
  - Record creation timestamp

**Relationships:**
- Many-to-one with doctors

**Constraints:**
- Check constraint: end_time > start_time
- Unique constraint on (doctor_id, day_of_week, start_time, end_time) for recurring schedules

**Considerations:**
- This table allows doctors to define their working hours
- Can be used to block specific time slots from booking
- Supports both recurring weekly schedules and one-time availability changes

---

### Table: payments (Optional but Recommended)

- **id**: INT, Primary Key, Auto Increment
  - Unique identifier for each payment record

- **appointment_id**: INT, Foreign Key → appointments(id), Not Null
  - References the appointment for which payment is made
  - One appointment can have multiple payments (partial payments, refunds)

- **patient_id**: INT, Foreign Key → patients(id), Not Null
  - References the patient making the payment
  - Indexed for patient payment history queries

- **amount**: DECIMAL(10, 2), Not Null
  - Payment amount
  - Must be positive

- **payment_method**: VARCHAR(20), Not Null
  - Payment method (e.g., "credit_card", "debit_card", "cash", "online", "insurance")
  - Validation via application code

- **payment_status**: TINYINT, Not Null, Default 0
  - Payment status enum:
    - 0 = Pending
    - 1 = Completed
    - 2 = Failed
    - 3 = Refunded

- **transaction_id**: VARCHAR(100), Null, Unique
  - External transaction ID from payment gateway
  - Unique constraint for payment gateway integration

- **payment_date**: TIMESTAMP, Not Null, Default CURRENT_TIMESTAMP
  - Date and time when payment was processed

- **notes**: TEXT, Null
  - Optional notes about the payment (refund reasons, etc.)

- **created_at**: TIMESTAMP, Not Null, Default CURRENT_TIMESTAMP
  - Record creation timestamp

**Relationships:**
- Many-to-one with appointments
- Many-to-one with patients

**Considerations:**
- Payment history is important for financial records and patient billing
- Consider PCI compliance if storing sensitive payment information
- Transaction IDs link to external payment gateways

---

## MongoDB Collection Design

MongoDB stores flexible, unstructured data that doesn't fit well into rigid relational tables. This includes free-form notes, prescription details, patient feedback, logs, messages, and file attachments. MongoDB's schema-less nature allows for easy evolution and flexible document structures.

### Collection: prescriptions

The prescriptions collection stores detailed prescription information with flexible structure, allowing for varying medication details, doctor notes, pharmacy information, and refill tracking.

**Example Document:**
```json
{
  "_id": "ObjectId('64abc123456789def0123456')",
  "patientId": 42,
  "patientName": "John Smith",
  "doctorId": 15,
  "doctorName": "Dr. Sarah Johnson",
  "appointmentId": 51,
  "appointmentDate": "2024-01-15T10:00:00Z",
  "medications": [
    {
      "name": "Paracetamol",
      "dosage": "500mg",
      "frequency": "Every 6 hours",
      "duration": "7 days",
      "quantity": 28,
      "instructions": "Take 1 tablet every 6 hours with food"
    },
    {
      "name": "Ibuprofen",
      "dosage": "400mg",
      "frequency": "Twice daily",
      "duration": "5 days",
      "quantity": 10,
      "instructions": "Take with meals to avoid stomach upset"
    }
  ],
  "doctorNotes": "Patient presented with fever and body aches. Prescribed medication for symptom management. Follow up if symptoms persist beyond 7 days.",
  "diagnosis": "Viral infection, likely flu",
  "refillCount": 2,
  "maxRefills": 3,
  "pharmacy": {
    "name": "Walgreens SF",
    "location": "123 Market Street, San Francisco, CA 94102",
    "phone": "4155551234"
  },
  "prescriptionDate": "2024-01-15T11:30:00Z",
  "status": "active",
  "tags": ["fever", "pain_management", "viral"],
  "attachments": [
    {
      "type": "lab_report",
      "url": "/uploads/prescriptions/lab_report_51.pdf",
      "uploadedAt": "2024-01-15T11:35:00Z"
    }
  ],
  "createdAt": "2024-01-15T11:30:00Z",
  "updatedAt": "2024-01-15T11:35:00Z"
}
```

**Field Descriptions:**
- `_id`: MongoDB ObjectId, automatically generated
- `patientId`: Reference to MySQL patients table (for joining if needed)
- `patientName`: Denormalized for quick access (patient name may change, but prescription record should maintain historical name)
- `doctorId`: Reference to MySQL doctors table
- `doctorName`: Denormalized doctor name
- `appointmentId`: Reference to MySQL appointments table - links prescription to specific appointment
- `appointmentDate`: When the appointment occurred
- `medications`: Array of medication objects (supports multiple medications per prescription)
- `doctorNotes`: Free-form text notes from doctor
- `diagnosis`: Optional diagnosis information
- `refillCount`: Number of times prescription has been refilled
- `maxRefills`: Maximum allowed refills
- `pharmacy`: Embedded document with pharmacy details (nested structure)
- `status`: Current status (active, completed, expired, cancelled)
- `tags`: Array of tags for categorization and search
- `attachments`: Array of file attachments (lab reports, images, etc.)
- `createdAt` / `updatedAt`: Timestamps for audit trail

**Considerations:**
- Patient and doctor names are denormalized (stored in document) to maintain historical accuracy even if names change in MySQL
- Medications array allows flexible number of medications per prescription
- Pharmacy information is embedded (not referenced) since it's specific to this prescription
- Tags enable easy searching and categorization
- Attachments array supports multiple file types per prescription

---

### Collection: patient_feedback

Stores patient feedback, reviews, and ratings for appointments and doctors. Flexible structure allows for various feedback types.

**Example Document:**
```json
{
  "_id": "ObjectId('64def7890123456789abc123')",
  "patientId": 42,
  "patientName": "John Smith",
  "appointmentId": 51,
  "doctorId": 15,
  "doctorName": "Dr. Sarah Johnson",
  "rating": 5,
  "feedbackType": "appointment",
  "feedbackText": "Excellent consultation. Dr. Johnson was very thorough and explained everything clearly. The appointment was on time and the clinic was clean.",
  "categories": {
    "communication": 5,
    "punctuality": 5,
    "treatment_quality": 5,
    "facility_cleanliness": 4
  },
  "isAnonymous": false,
  "isPublished": true,
  "tags": ["positive", "on_time", "thorough"],
  "response": {
    "doctorId": 15,
    "responseText": "Thank you for your feedback! We appreciate your kind words.",
    "respondedAt": "2024-01-16T09:00:00Z"
  },
  "createdAt": "2024-01-15T14:30:00Z",
  "updatedAt": "2024-01-16T09:00:00Z"
}
```

**Field Descriptions:**
- `rating`: Overall rating (1-5 scale)
- `feedbackType`: Type of feedback (appointment, doctor, clinic, general)
- `feedbackText`: Free-form feedback text
- `categories`: Nested object with category-specific ratings
- `isAnonymous`: Flag for anonymous feedback
- `isPublished`: Flag to control visibility on public pages
- `tags`: Array of tags for categorization
- `response`: Optional embedded document with doctor/admin response
- Timestamps for audit trail

**Considerations:**
- Supports both structured ratings and unstructured text feedback
- Response can be added later by doctor or admin
- Categories allow detailed rating breakdown
- Tags enable sentiment analysis and search

---

### Collection: appointment_logs

Stores detailed logs of appointment-related events for audit trail and tracking. Captures check-ins, cancellations, status changes, and other events.

**Example Document:**
```json
{
  "_id": "ObjectId('64ghi4567890123456789def4')",
  "appointmentId": 51,
  "patientId": 42,
  "doctorId": 15,
  "eventType": "check_in",
  "eventDescription": "Patient checked in at reception",
  "timestamp": "2024-01-15T09:45:00Z",
  "location": "reception",
  "performedBy": {
    "userId": 42,
    "userType": "patient",
    "userName": "John Smith"
  },
  "metadata": {
    "checkInMethod": "self_service_kiosk",
    "arrivalTime": "2024-01-15T09:45:00Z",
    "appointmentTime": "2024-01-15T10:00:00Z",
    "waitTime": "15 minutes"
  },
  "ipAddress": "192.168.1.100",
  "deviceInfo": {
    "type": "mobile",
    "browser": "Chrome",
    "os": "iOS"
  },
  "createdAt": "2024-01-15T09:45:00Z"
}
```

**Field Descriptions:**
- `eventType`: Type of event (check_in, check_out, cancelled, rescheduled, status_changed, etc.)
- `eventDescription`: Human-readable description
- `timestamp`: When the event occurred
- `location`: Where the event occurred (reception, online, phone, etc.)
- `performedBy`: User who triggered the event (embedded document)
- `metadata`: Flexible object for event-specific data
- `ipAddress`: For security and audit purposes
- `deviceInfo`: Device information for analytics

**Considerations:**
- Comprehensive audit trail for compliance and debugging
- Flexible metadata allows different event types to store relevant information
- Can be used for analytics (average wait times, check-in patterns, etc.)
- Supports both system-generated and user-triggered events

---

### Collection: messages

Stores chat messages and communications between patients and doctors, or system notifications. Flexible structure supports various message types.

**Example Document:**
```json
{
  "_id": "ObjectId('64jkl7890123456789abc567')",
  "conversationId": "conv_51_15_42",
  "senderId": 15,
  "senderType": "doctor",
  "senderName": "Dr. Sarah Johnson",
  "recipientId": 42,
  "recipientType": "patient",
  "recipientName": "John Smith",
  "messageType": "text",
  "content": "Hi John, I've reviewed your test results. Please schedule a follow-up appointment to discuss them.",
  "appointmentId": 51,
  "isRead": false,
  "readAt": null,
  "attachments": [
    {
      "type": "document",
      "name": "test_results.pdf",
      "url": "/uploads/messages/test_results_51.pdf",
      "size": 245678,
      "uploadedAt": "2024-01-16T10:00:00Z"
    }
  ],
  "tags": ["follow_up", "test_results"],
  "priority": "normal",
  "createdAt": "2024-01-16T10:00:00Z",
  "updatedAt": "2024-01-16T10:00:00Z"
}
```

**Field Descriptions:**
- `conversationId`: Unique identifier for the conversation thread
- `senderId` / `senderType`: Who sent the message
- `recipientId` / `recipientType`: Who receives the message
- `messageType`: Type of message (text, image, document, system_notification)
- `content`: Message content (text or reference to media)
- `appointmentId`: Optional link to related appointment
- `isRead` / `readAt`: Read status tracking
- `attachments`: Array of file attachments
- `tags`: Categorization tags
- `priority`: Message priority (low, normal, high, urgent)

**Considerations:**
- Supports one-on-one and potentially group conversations
- Attachment support for sharing documents and images
- Read status tracking for notification systems
- Can link to appointments for context
- Flexible message types support future expansion (video, voice, etc.)

---

### Collection: doctor_notes

Stores free-form notes that doctors create during or after appointments. These notes can be private (only visible to the doctor) or shared with the patient.

**Example Document:**
```json
{
  "_id": "ObjectId('64mno0123456789abcdef890')",
  "doctorId": 15,
  "doctorName": "Dr. Sarah Johnson",
  "appointmentId": 51,
  "patientId": 42,
  "patientName": "John Smith",
  "noteType": "clinical",
  "title": "Follow-up notes - Patient recovery",
  "content": "Patient reports improvement in symptoms. Temperature normalized. Advised to continue medication and monitor for any recurrence. Patient should return if symptoms worsen.",
  "isPrivate": false,
  "isSharedWithPatient": true,
  "tags": ["follow_up", "recovery", "medication"],
  "attachments": [
    {
      "type": "image",
      "name": "patient_chart.jpg",
      "url": "/uploads/notes/chart_51.jpg",
      "description": "Patient temperature chart"
    }
  ],
  "createdAt": "2024-01-15T11:00:00Z",
  "updatedAt": "2024-01-15T11:00:00Z"
}
```

**Field Descriptions:**
- `noteType`: Type of note (clinical, administrative, personal, reminder)
- `title`: Optional title for quick reference
- `content`: Main note content (free-form text)
- `isPrivate`: Whether note is private to doctor
- `isSharedWithPatient`: Whether patient can view this note
- `tags`: Categorization and search tags
- `attachments`: Array of attached files (images, documents, etc.)

**Considerations:**
- Flexible structure allows doctors to take various types of notes
- Privacy flags control visibility
- Tags enable easy searching through notes
- Can attach files for additional context
- Links to appointments for chronological organization

---

## Design Decisions and Rationale

### Why MySQL for Core Tables?

1. **Data Integrity**: Patients, doctors, and appointments require strict referential integrity and validation
2. **ACID Transactions**: Appointment booking requires atomic operations to prevent double-booking
3. **Structured Queries**: Complex queries with joins (e.g., "all appointments for a doctor with patient details") are efficient in MySQL
4. **Established Patterns**: Relational model is well-suited for entity relationships (patient → appointments → doctors)

### Why MongoDB for Flexible Data?

1. **Schema Evolution**: Prescriptions, feedback, and notes have varying structures that may evolve over time
2. **Nested Data**: Prescriptions with multiple medications, feedback with category ratings fit naturally in documents
3. **Optional Fields**: Not all documents need the same fields (e.g., some feedback has responses, others don't)
4. **Rich Data Types**: Arrays, nested objects, and attachments are easier to model in MongoDB
5. **Scalability**: Logs and messages can grow large; MongoDB handles large collections efficiently

### Data Relationships Between MySQL and MongoDB

- **Reference Pattern**: MongoDB documents store IDs referencing MySQL records (e.g., `patientId`, `doctorId`, `appointmentId`)
- **Denormalization**: Some fields are duplicated (e.g., patient names in prescriptions) to maintain historical accuracy and improve read performance
- **Service Layer**: Application service layer coordinates data from both databases for complete views

### Future Considerations

1. **Schema Evolution**: MongoDB collections can evolve without migrations, but MySQL tables require careful migration planning
2. **Data Synchronization**: If patient/doctor names change in MySQL, consider whether to update MongoDB documents or keep historical names
3. **Indexing**: Add indexes on frequently queried fields in both databases (e.g., `appointmentId` in MongoDB, `appointment_time` in MySQL)
4. **Archiving**: Consider archiving old appointments and logs to maintain performance while preserving historical data
5. **Backup Strategy**: Both databases require backup strategies, but MongoDB's document model may require different backup approaches

---

## Summary

This dual-database design leverages the strengths of both MySQL and MongoDB:

- **MySQL** provides structure, integrity, and transactional guarantees for core operational data
- **MongoDB** provides flexibility and scalability for unstructured, evolving data

The service layer coordinates between both databases, presenting a unified interface to the application while maintaining data consistency and appropriate use of each database's capabilities.

